
% [Consiste na maneira de trabalhar o objeto de pesquisa, as ações pelas quais serão alcançados os resultados esperados da pesquisa.
% Descrever:
% \begin{itemize}
% 	\item processo de estudo das fontes bibliográficas
% 	\item Instrumentos e fontes para coleta de dados
% 	\item Processos e métodos para a realização do trabalho (uso de ferramentas, linguagens de especificação, descrição das fases do trabalho de pesquisa, etc)
% \end{itemize}
% ]

Para atingir nossos objetivos, iremos coletar os dados gerados pelas ferramentas
implantadas ao final de cada sprint da equipe de Manutenção e Evolução de Software.
Neste projeto, será utilizado Pylint e Pygenie, ferramentas que irão realizar a
análise estática do código.

Pylint checa por erros no código, tentando padronizar o código e ao mesmo tempo
procurar por \textit{bad smells}, ou seja, por trechos do código que ferem as boas
práticas de programação. O pylint segue as diretrizes do \textit{PEP 008}, que é
um guia de boas práticas para projetos escritos em \textit{Python}. Lembrando sempre
que o pylint não é algo a ser seguido "a ferro e fogo", e serve apenas como sugestão
para refatoração de código. Além do \textit{PEP 008}, o pylint também segue as
práticas sugeridas por Matin Fowler em seu livro \textit{Refactoring}.

Pygenie mede a complexidade ciclomática de um projeto, dando uma nota para classe
e/ou métodos/funções. Complexidade ciclomática é uma medida para os caminhos
linearmente independentes do projeto, ou seja, mede a quantidade de ramificações
em trechos de código. A notas são dadas em forma de números, sendo o número 7
escolhido por se acreditar ser o número médio de coisas que um ser humano consegue
ter em mente ao mesmo tempo. O pygenie, por padrão, mostra apenas o que houver
uma nota de complexidade alta, e para mostrar tudo, deve ser adicionado um parâmetro
na execução da ferramenta. Lembrando que mesmo com esses dados, o resultado deve ser
visto apenas como uma possível sugestão de refatoração, e não como algo obrigatório
a ser tratado.
